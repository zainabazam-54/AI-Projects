# -*- coding: utf-8 -*-
"""CNN Classifier.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BJL1ys3EJJPMxKz9yCu4eYNnb11iRVmN
"""

import matplotlib.pyplot as plt
import numpy as np

import tensorflow as tf
import tensorflow_datasets as tfds

from tensorflow import keras

"""Importing the dataset:"""

import kagglehub

# Download latest version
path = kagglehub.dataset_download("andrewmvd/animal-faces")

print("Path to dataset files:", path)



import tensorflow as tf
from tensorflow.keras.preprocessing import image_dataset_from_directory

base_dir = "/kaggle/input/animal-faces"

train_ds = image_dataset_from_directory(
    directory=f"{base_dir}/afhq/train",
    image_size=(224, 224),
    batch_size=32
)

test_ds = image_dataset_from_directory(
    directory=f"{base_dir}/afhq/val",
    image_size=(224, 224),
    batch_size=32
)

train_ds

"""Normalizing"""

normalization_layer = tf.keras.layers.Rescaling(1./255)

train_ds = train_ds.map(lambda x, y: (normalization_layer(x), y))
test_ds = test_ds.map(lambda x, y: (normalization_layer(x), y))

model = keras.Sequential([
    keras.layers.Conv2D(64, 3, activation='relu',
                        input_shape=(224, 224, 3)),
    keras.layers.Conv2D(32, 3, activation='relu'),
    keras.layers.Flatten(),
    keras.layers.Dense(3, activation='softmax')
])

model.compile(optimizer='adam',
              loss=keras.losses.SparseCategoricalCrossentropy(),
              metrics=['accuracy'])

model.fit(train_ds, epochs=5,
          batch_size=32)

model.evaluate(test_ds)

import matplotlib.pyplot as plt
import numpy as np
from tensorflow.keras.preprocessing import image
import tensorflow as tf

# Path to the image (Replace with the actual path to your test image)
img_path = '/kaggle/input/animal-faces/afhq/train/cat/flickr_cat_000024.jpg'  # Update with your image path


img = image.load_img(img_path, target_size=(224, 224))

# Display the image
plt.imshow(img)
plt.axis('off')  # Hide axes for better visualization
plt.show()

# Convert the image to a numpy array and add batch dimension (no need to normalize since you already did)
img_array = image.img_to_array(img)  # Convert image to array
img_array = np.expand_dims(img_array, axis=0)  # Add batch dimension

# Now, use the trained model to make a prediction
predictions = model.predict(img_array)

# Assuming your class labels are ['cat', 'dog', 'wild'] (adjust this if necessary)
class_labels = ['cat', 'dog', 'wild']  # Adjust to match your model's class labels
predicted_class = class_labels[np.argmax(predictions)]

# Output the prediction result
print(f"The model predicts this image is: {predicted_class}")